---
title: 跨域方案解决
date: 2019-01-10 18:39:20
tags: JavaScript
categories: JavaScript
---

### 跨域方案解决
_`ajax`的出现，推动了web的发展。随之，为了防止恶意文档，保护用户信息安全。浏览器制定了同源安全策略_
#### 1. 同源安全策略是什么？
**很简单，接着看！**

##### 1.1 什么是同源
**同源就是比较两个`URL`地址，当他们满足一定的条件，他们就是同源的。**
**同时满足下面三个条件**

- 协议相同
- 主机相同
- 端口相同

看个例子
```http
https://www.baidu.com/s?ie=UTF-8&wd=a
// 协议 https
// 主机 www.baidu.com
// 端口 默认端口为80所以没有显示。
```
**练习**
下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例:

| **URL**  | **结果** | **原因** |
| ---- | :------- | -------- |
|     http://store.company.com/dir2/other.html | 同源 | 只有路径不同 |
|    http://store.company.com/dir/inner/another.html  | 同源 | 只有路径不同 |
|   https://store.company.com/secure.html   | 不同源 | 协议不同 |
|   http://store.company.com:81/dir/etc.html   | 不同源 | 端口不同 ( `http://` 默认端口是80) |
|   http://news.company.com/dir/other.html   | 不同源 | 主机不同 |

##### 1.2 同源安全策略

  同源安全策略，是浏览器方提供一种的安全策略。举个例子：我们登陆了一个网址为`http://www.A.com`的网站，那么默认我们只能请求和`http://www.A.com`同源的网站。在`http://www.A.com`网站，发送的所有请求地址只要是和`http://www.A.com`网站同源的地址，那么可以访问。但是如果此时在`http://www.A.com`向`http://www.B.com`发送一个请求。此时就会触发浏览器同源安全策略。

**演示**
在一个地址为`http://localhost:3000/`的网址地址中的页面，向地址为`http://localhost:3001/`的网址发送一个ajax请求。
```ts
        window.onload = function() {

            let xhr = new XMLHttpRequest();

            xhr.open('get', 'http://localhost:3001/get');

            xhr.send();

            xhr.onload = function() {
                console.log(xhr.responseText);
           }
```
ajax请求触发浏览器同源策略
![ajax_跨域](https://github.com/askwuxue/askwuxue.github.io/assets/32808762/13bac764-e1b3-4ab1-a28b-447221422579)

如上，我们用`ajax`进行了一个跨域请求，触发了浏览器的同源安全策略。因此，不能使用`ajax`进行请求，聪明的人想出了各种办法。其中`jsonp`是最早的解决方案之一。

#### 2. 跨域方案解决之`JSONP（jsonp json with padding ）`
_我们已经知道了，`ajax`不支持跨域请求。但是我们页面中是有支持跨域请求的存在的，如`script`标签的`src`属性，用来加载`JavaScript`资源，请求方式是`GET`。这种方式是支持跨域的，这也是我们在页面上可以引入在线的`jQuery`等资源的原因。所以，我们可以利用这个`script`标签的这个特性来进行跨域请求。_
##### 2.1 script标签的src属性
我们必须清楚的认识到以下3点
- `script`中包含的必须可执行的`JavaScript`代码
- 服务端必须返回`JavaScript`代码
- 必须要有动态创建的`script`标签。因为请求是动态的，我们需要根据请求动态生成`script`标签
##### 2.1 JSONP实现思路
1. 在客户端定义一个函数。
2. 在服务端返回第一步定义函数的调用给客户端（服务端无法调用，只是将函数的调用作为字符串返回）。
3. 客户端接收到该函数调用，然后执行。
**补充： 1. 在上述第第二步中，服务端将真正想返回的数据放在函数的实参中。在客户端调用时，就可以拿到对应的数据**
	**2. 我们定义的函数必须是全局的，这样服务端返回后，我们才能正常调用。因为服务端返回的函数调用是全局下的**

##### 2.1 JSONP请求封装
```ts
// 参数说明
// 调用JSONP请求传递的用户需要传递
options = {
	url: 请求地址,
	// 用户自定义参数
	params: {key: value},
	// 用户请求成功回调函数
	succss: function() {}
}
function jsonp(options) {
    // 获得页面body标签
    let body = document.getElementsByTagName('body')[0];
    // 动态创建script标签
    let script = document.createElement('script');
    // 用户请求的地址
    script.src = options.url;
    // 生成一个随机数，我们想将函数的名称发送给服务端，并要求服务端返回同名函数。因为我们在客户端上将定义该函数。因此，要保证函数名不一致，所以使用随机数
    let random = Math.random().toString().replace('.', '');
    // 随机函数名
    let fn = ('jsonp' + random);
    // 必须将fn挂在在全局下，否则服务端返回函数无法执行。
    window[fn] = function() {};
    // 将用户调用的成功的函数体赋值给全局下的函数
    window[fn] = options.success;
    // 真正的请求地址
    script.src += `?callback=${fn}`;
    // 用户传递了自定义参数
    if (options.params) {
        let paramStr = '';
        Object.keys(options.params).forEach((item) => {
            paramStr += ('&' + item + '=' + options.params[item]);
        })
        script.src += paramStr;
    }
    // 动态生成script
    body.appendChild(script);
    // script 成功请求后将script从DOM中删除
    script.onload = function() {
        body.removeChild(script);
    }
}
```
##### 1.3 JSONP客户端实现代码

```ts
	// 请求url中的参数
    let urlParams = req.url.substring(req.url.indexOf('?') + 1);
    // 对请求参数切割
    let paramsArr = urlParams.split('&');
    // 请求参数对象
    let paramsObj = {};
    for (let i = paramsArr.length; i--; i < 0) {
        let temp = paramsArr[i].split('=');
        paramsObj[temp[0]] = temp[1];
    }
    // 返回的数据
    let data = JSON.stringify({ name: "wuxue" });
    // TODO 浏览器只能接受字符串
	// 返回给客户端的内容
    let resFn = `${paramsObj['callback']}(${data})`;
    res.send(resFn);
```



_如上，简单的实现了JSONP请求，解决了跨域的问题。跨域方案的解决，有很多种方式。JSONP只是其中最古老，并且受限比较多的一种。JSONP主要的问题如下_

- 只支持GET请求方式

- 不够优雅，有些繁琐

- 非种正统的方式

参考资料
> 阮一峰-[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)
> 阮一峰-[跨域资源共享CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)

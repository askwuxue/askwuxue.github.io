---
title: 闭包到底是什么
date: 2018-08-20 13:09:10
tags: JavaScript
categories: JavaScript
---

###  闭包到底什么

#### 1. 定义
> JavaScript高级程序语言设计: _闭包是指有权访问另一个函数作用域中变量的函数_
根据这个定义，我们去分析
**闭包是什么？** `一个函数`
**闭包是什么函数？**`一个可以访问其他函数作用域中变量的函数`
我们仔细分析其中的关键字，`函数`、`作用域`、`变量`

##### 1.1 深入分析函数
  `JavaScript`在`ES6`前是没有块级作用域的。但是有函数作用域，类似块级作用域，在函数内部使用`var`关键字声明一个变量。**直接**在函数外部访问函数内部的变量是访问不到的。
**注意: 函数内部的变量必须使用`var`关键字声明，如果不使用var关键字声明。在函数外部是可以直接使用这个变量的，因为这时，函数内部的这个变量是全局变量。如下，在函数内部有一个局部变量和一个全局变量**

```javascript
	function fun() {
		var a = 1;	// 局部变量
		b = 2;		// 全局变量
	}
```

上面说到，在函数外部不能直接访问函数内的局部变量。反过来不然，在函数内部，是可以访问到全局变量的。这个时候需要涉及到作用域的相关知识。
###### 1.1.1 作用域
> _作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性_
  简单来说，作用域就是你到底能不能访问到某些变量，函数，对象等。定义在全局上的，都是可以访问的。为什么呢？举个列子，全局可以理解称为一个所有人都可以访问的仓库，你需要一个东西，不需要和任何人打招呼你就可以进行拿，没人管你。
  如果你有自己的家，你需要什么，根据就近原则，先在自己的家里找，找不到了。你才会向东西更多，更全的地方去找。类似于很多个同心圆，总是从最内层一直向外扩散的感觉。
  函数作用域，相当于和你没有交集的人家，是不会允许你平白无故去人家的家里拿东西。即便人家的家里有这件东西。请看
```javascript
	var b = 1;
	function father() {
		var b = 2;
		function son() {
			console.log(b);   // 2
		}
	}
```
**** 作用域链**
  上面这段伪代码，`son()`函数要访问`b`变量，但是`son`函数内部没有b变量。就会向上面找，为什么向上面找，因为`son`函数是在`father`函数内部的，它们存在包含关系。`son`函数可以向上寻找。找到了`b`变量，取到了值。就不会继续找了。假如，`father`函数内部没有`b`变量呢？那么就会在`father`函数的上一层找，`father`的上一层是全局变量，全局变量中定义了`b`变量，所以也可以找到，只不过这个时候的`b`的值为1。这样一层层向上寻找的过程就形成了一条作用域链。

  我们说了那么多，都在说从内部是如何访问外部的变量的。而外部是无法直接访问函数内部作用域的变量的。如下所示
```javascript
	function f1() {
		var a = 1;
	}
	console.log(a) // 想要访问f1内部的变量a。
```
  上面的代码，想要在函数外部使用函数内部的变量。但是由于函数内部作用域的限制，无法实现。人类总是有办法解决。请向下看。
###### 1.1.2 函数返回值功不可灭
  `JavaScript`的函数返回值可以返回任何类型的值。所以，返回值是一个函数也没有什么奇怪的。因此，`result`接收到的是一个没有调用的函数。`result()`调用后，我们在全局环境中通过了`f2函数`间接的拿到了`f1函数`内部的值。`f2函数`就是一个闭包。回过头看闭包的定义就变得一目了然。

```javascript
	function f1() {
		var a = 1;
		function f2() {
			console.log(a);
		}
		return f2;
	}
	var result = f1();	// f2() { console.log(a); }
	result();	// 1
	console.log(a) // 想要访问f1内部的变量a。
```
> 阮一峰: 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 



#### 闭包的作用
1. 可以访问函数内部的变量。
2. 可以让变量一直存在内存中。（可以参考阮一峰老师的例子）如下所示：
```javascript
function f1(){
　　　　var n = 999;
　　　　nAdd = function(){ 
　　　　n += 1
　　　　}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　}
　　
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
```
正常情况下，在函数内部定义的变量，当该函数被调用后，根据JavaScript的垃圾回收机制，函数内部的变量都会被垃圾回收器清除，释放内存。但是根据上述代码所示。`n`并没有被回收，也就是一直被保存在内存中。所以会造成内存消耗过大，甚至在某些浏览器会引起内存泄露的问题。所以需要谨慎使用闭包。

总结: 个人觉得闭包在设计上就是一个缺陷，是因为语言特性所决定的。在ES6中有了`let`等新特性，出现了块级作用域。全局变量和内部变量界限分明或许是最好的解决方案。